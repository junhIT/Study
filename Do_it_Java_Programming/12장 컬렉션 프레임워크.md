[TOC]





# 제네릭

- 여러 자료형을 사용 가능
- 제네릭 프로그래밍( java 5~ ) :
  - 어떤 값이 하나의 참조 자료형이 아닌 여러 참조 자료형을 사용할 수 있도록 프로그래밍 하는 것



## 제네릭의 필요성

```
public class ThreeDPrinter {
	private Object material;
	
	public void setMaterial(Object material) {
		this.material = material;
	}
	
	public Object getMaterial() {
		return material;
	}
}
```

```
public class GenericTest {

	public static void main(String[] args) {
		ThreeDPrinter printer = new ThreeDPrinter();
		
		Student st = new Student(0, null);
		printer.setMaterial(st); // 자동 형 변환됨
		
		Student st2 = (Student) printer.getMaterial(); // 직접 형 변환 필요
	}
}
```

- Object는 모든 클래스의 최상위 클래스이므로, 모든 클래스는 Object로 형변환이 가능함
- set Method: 하위 클래스는 Object클래스로 자동 형변환됨
- get Method : 하위 클래스의 자료형으로 변환이 필요함
- 여러 자료형이 사용될 수 있는 곳에 특정 자료형을 지정하지 않고, 클래스나 메서드를 정의한 후 어떤 자료형을 사용할지 지정하는 방식



## 제네릭 클래스 정의

- 보통 type Paramter로 변수명은 T로 작성

```
public class GenericPrinter<T> { // <T> : 제네릭클래스
	private T material;
	
	public void setMaterial(T material) {
		this.material = material;
	}
	
	public T getMaterial() {
		return material;
	}
}
```

- 다이아몬드 연산자 <> ( java 7~ )

  - 제네릭 자료형의 클래스를 생성할 때 생성자에 사용하는 자료형을 명시하지 않는 연사자

  - ArrayList<**String**> list = new ArrayList<>();
    - 우측 다이아몬드 연사자 내부에 생략된 부분이 String임을 컴파일러가 유추할 수 있기 때문에 생성 부분에서 생략 가능
    
    
- 자료형 매개변수 T와 static
  - static 변수와 메서드는 인스턴스변수가 생성되기 이전에 생성
  - static 메서드에서는 인스턴스 변수를 사용할 수 없음
  - 제네릭 클래스의 인스턴스가 생성되는 순간 T의 자료형이 정해짐
    - 따라서 static 변수의 자료형이나, static 메서드 내부 변수의 자료형으로 T를 사용할 수 없다.



- T 자료형에 사용할 자료형 제한

```
public class GenericPrinter<T extends Material> { // extends 예약어로 사용할 수 있는 자료형에 제한을 둠
	private T material; 
	
	material.doPrinting(); // extends 명령어를 사용할 경우 material 클래스에서 선언한 메서드 사용 가능
							// extends 명령어를 사용하지 않으면 기본 Object 클래스의 메서드만 사용 가능
}
```



## 제네릭 메서드 활용하기

- 자료형 매개변수를 여러 개 사용하는 제네릭 메서드
- T와 V는 정수일수도 실수일수도 있어 자료형 매개변수로 선언

```
public class Point<T, V> {
	T x;
	V y;
	
	Point(T x, V y) {
		this.x = x;
		this.y = y;
	}
	
	public T getX() {
		return x;
	}
	
	public V getY() {
		return y;
	}
}
```



# 컬렉션 프레임워크

- 자료구조

  - 프로그램 실행 중 메모리에 자료를 유지, 관리하기 위해 사용

  

- 컬렉션 프레임워크

  - 자바에서는 필요한 자료구조를 미리 구현하여 java.util 패키지에서 제공 ( 자바 컬렉션 프레임워크 )



- 자바 컬렉션 프레임워크

  - Collection 인터페이스와 Map인터페이스 기반으로 이루어짐

  

## Collection 인터페이스

- **하나의 자료**를 모아서 **관리**하는데 필요한 기능을 제공



- **List 인터페이스**와 **Set 인터페이스**가 있음
  - List : 순서가 있는 자료 관리, 중복 허용,
    - ArrayList, Vector, LinkedList, Stack, Queue ...
  - Set : 순서가 정해져 있지 않음. 중복을 허용하지 않음
  - HashSet, TreeSet ...



- 자주 사용하는 Method

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| boolean add(E  e)        | Collection에 객체를 추가합니다.                              |
| void clear()             | Collection의 모든 객체를 제거합니다.                         |
| Iterator<E> iterator     | Collection을 순환할 반복자(Iterator)을 반환합니다.           |
| boolean remove(Object o) | Collection에 매개변수에 해당하는 인스턴스가 존재하면 제거합니다. |
| int size()               | COllection에 있는 요소의 개수를 반환합니다.                  |



## Map 인터페이스 

- **쌍(key-value)**으로 된 **자료들을 관리**하는 데 유용한 기능을 제공
- Map은 기본적으로 **검색용 자료구조**



- Map인터페이스를 구현한 대표 클래스
  - HashTable : Properties
  - HashMap
  - TreeMap



- 자주 사용하는 Method

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| V put(K key, V value)                    | key에 해당하는 value 값을 map에 넣습니다                     |
| V get(K key)                             | key에 해당하는 value 값을 반환합니다.                        |
| boolean isEmpty()                        | Map이 비었는지 여부를 반환합니다.                            |
| boolean containsKey(Object key)          | Map에 해당 Key가 있는지 여부를 반환합니다.                   |
| boolean constrainsValue(Object value)    | Map에 해당 value가 있는지 여부를 반환합니다.                 |
| Set keyset()                             | key 집합을 Set로 반환합니다(중복 안 되므로 Set)              |
| Collection values()                      | value를 Collection으로 반환합니다(중복 무관)                 |
| V remove(key)                            | key가 있는 경우 삭제합니다                                   |
| boolean remove(Object key, Object value) | key가 있는 경우 key에 해당하는 value가 매개변수와 일치할 때 삭제합니다. |





# List 인터페이스

- 객체를 순서에 따라 저장하고 유지하는 데 필요한 메서드가 선언되어 있음



## ArrayList 클래스

- 객체 배열을 구현한 클래스, 컬렉션 인터페이스와 하위 List 인터페이스를 구현



## Vector 클래스

- 배열을 구현한 클래스



- ArrayList와의 차이 : **동기화 지원** 여부이다.
  - **동기화**(Synchronization)란?
    - 두 개 이상의 스레드가 **동시**에 Vector를 사용할 때 오류가 나지 않도록 **실행 순서를 보장**하는 것



- 스레드

  - 작업의 단위

  - 프로그램이 **메모리에서 수행**되려면 **스레드 작업이 생성**되어야 한다.

    - 단일 스레드(single thread) 
      - 하나의 스레드만 수행
    - 멀티 스레드(multi-thread)
      - 두 개 이상의 스레드가 동시에 실행

  - 두 개 이상의 **스레드**가 **동시에 실행**되면 같은 메모리 공간(리소스)에 접근하므로 **변수**나 **메모리 상태**에 **오류**가 발생할 수 있다.

    이 때 메모리에 동시에 접근하지 못하도록 순서를 맞추는 것이 **동기화**이다.



- **비동기 작업**일 경우 **ArrayList**를 사용하자!

  - Vector는 동기화를 구현하기 위해 **메서드를 호출**할 때 배열 객체에 **잠금(lock)**을 수행하고 메서드 수행이 끝나면 **잠금(lock)을 해제**한다
  - 잠금과 잠금 해제가 일어나므로 ArrayList보다 수행 속도가 느리다.

  

- **ArrayList**에서 **동기화** 사용

  ```
  Collections.synchronizedList(new ArrayList<String>());
  ```

  

